# zustand

![image](https://github.com/livid-fe-study/24-library-deep-dive/assets/40662323/685aef7c-59b1-43c2-aacf-9e54519ad382)


- flux íŒ¨í„´ â†’ redux
    
    <aside>
    ğŸ’¡ **Store**ë¼ëŠ” ìƒíƒœ ì €ì¥ì†Œë¥¼ ê¸°ë°˜ìœ¼ë¡œ, **Action íƒ€ì…ì„ Reducerì— ì „ë‹¬**í•˜ë©´ í•´ë‹¹ íƒ€ì…ì— ë§ëŠ” ë™ì‘ì— ë”°ë¼ ìƒíƒœê°’ì„ ê°±ì‹ 
    
    ì»´í¬ë„ŒíŠ¸ëŠ” **Selector** ë¥¼ ì‚¬ìš©í•´ Storeì—ì„œ **í•„ìš”í•œ ìƒíƒœê°’ì„ êµ¬ë…(subscribing)**í•˜ëŠ” í˜•íƒœ
    
    </aside>
    
- ë‹¨ë°©í–¥ ë°ì´í„° êµ¬ì¡° â†’ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ìƒíƒœ ê´€ë¦¬

```jsx
import { create } from 'zustand'

const useStore = create((set) => ({
  count: 1,
  inc: () => set((state) => ({ count: state.count + 1 })),
}))

function Counter() {
  const { count, inc } = useStore()
  return (
    <div>
      <span>{count}</span>
      <button onClick={inc}>one up</button>
    </div>
  )
}
```

---

```tsx
const store = create(set => ({
  text: '',
  count: 0,
  // ê°ì²´ë¥¼ ì§ì ‘ ì „ë‹¬í•˜ì—¬ ìƒíƒœë¥¼ ê°±ì‹ í•˜ëŠ” ê²½ìš°
  setCount: newCount => set({ count: newCount }),
  // í•¨ìˆ˜ë¥¼ ì „ë‹¬í•˜ì—¬ ìƒíƒœë¥¼ ê°±ì‹ í•˜ëŠ” ê²½ìš°
  increment: () => set(state => ({ count: state.count + 1 })),
  setText: text => set({ text })
}));

store.subscribe(state => console.log('Something's changed: ', state)); // ì–´ë–¤ ìƒíƒœê°€ ë³€ê²½ë˜ë”ë¼ë„ ë¡œê·¸ê°€ ì¶œë ¥ë¨
store.subscribe(
  state => console.log('Count is changed: ', count),
  state => state.count
); // count ê°’ì´ ë°”ë€” ë•Œë§Œ ë¡œê·¸ê°€ ì¶œë ¥ë¨
store.subscribe(
  state => console.log('Text has been changed: ', text),
  state => state.text
); // text ê°’ì´ ë°”ë€” ë•Œë§Œ ë¡œê·¸ê°€ ì¶œë ¥ë¨

store.setText('Changed'); // text ê°’ë§Œ ë³€ê²½
// ê²°ê³¼
// Something's changed: [Object]
// Text has been changed: Changed
```

---

---

## create

```tsx
export const create = (<T>(createState: StateCreator<T, [], []> | undefined) =>
  createState ? createImpl(createState) : createImpl) as Create
```

## createImpl

```tsx
const createImpl = <T>(createState: StateCreator<T, [], []>) => {
	// ..
	
	// return í•  apië“¤
  const api =
    typeof createState === 'function' ? createStore(createState) : createState 

  const useBoundStore: any = (selector?: any, equalityFn?: any) =>
    useStore(api, selector, equalityFn)

  Object.assign(useBoundStore, api)

  return useBoundStore
}
```

### createStore

```tsx
export const createStore = ((createState) =>
  createState ? createStoreImpl(createState) : createStoreImpl) as CreateStore
```

### createStoreImpl â­ï¸

- 2ê°œì˜ ë¡œì»¬ ë³€ìˆ˜  `state`, `listeners`ë¥¼ ì„ ì–¸í•˜ê³  ì´ ë³€ìˆ˜ë“¤ì„ ì°¸ì¡°í•˜ëŠ” í´ë¡œì €ë“¤ì„ ìƒì„±
- create í•¨ìˆ˜ì˜ ì¸ìë¡œ ì „ë‹¬ë°›ì€ createState í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ì—¬ ì´ˆê¸°ê°’ ì„¤ì •í•˜ê³  apië“¤ì„ ë°˜í™˜

```tsx
const createStoreImpl: CreateStoreImpl = (createState) => {
  type TState = ReturnType<typeof createState>
  type Listener = (state: TState, prevState: TState) => void
  let state: TState // NOTE: state ì„ ì–¸
  const listeners: Set<Listener> = new Set() // ì¤‘ë³µì œê±° ìœ„í•´ Set ì‚¬ìš©

  const setState: StoreApi<TState>['setState'] = (partial, replace) => {
    // í´ë¡œì €
    // partial === function ---> setState(prev => ({...prev, ...partial(prev)}))
    //// í˜„ì¬ stateë¥¼ partialì— ì¸ìë¡œ ì „ë‹¬
    // function ì´ ì•„ë‹ˆë©´
    // setState(partial)
    const nextState =
      typeof partial === 'function'
        ? (partial as (state: TState) => TState)(state)
        : partial

    // nextStateê°€ stateì™€ ë‹¤ë¥´ë©´ stateë¥¼ ê°±ì‹ 
    if (!Object.is(nextState, state)) {
      const previousState = state
      state =
        replace ?? (typeof nextState !== 'object' || nextState === null)
          ? (nextState as TState)
          : Object.assign({}, state, nextState)

      // listenersë¥¼ ìˆœíšŒí•˜ë©´ì„œ stateê°€ ë³€ê²½ë˜ì—ˆìŒì„ ì•Œë¦¼
      listeners.forEach((listener) => listener(state, previousState))
    }
  }

  // í´ë¡œì €
  const getState: StoreApi<TState>['getState'] = () => state

	// í´ë¡œì €
  const getInitialState: StoreApi<TState>['getInitialState'] = () =>
    initialState

  // í´ë¡œì €
  const subscribe: StoreApi<TState>['subscribe'] = (listener) => {
    listeners.add(listener)
    // NOTE: Unsubscribe function
    return () => listeners.delete(listener)
  }

  // í´ë¡œì €
  const destroy: StoreApi<TState>['destroy'] = () => {
    listeners.clear()
    // Set clear https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set/clear
  }

  const api = { setState, getState, getInitialState, subscribe, destroy }
  
  // ì¸ìë¡œ ì „ë‹¬ë°›ì€ createState í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìµœì´ˆ ìƒíƒœë¥¼ ì„¤ì •í•œë‹¤.
  const initialState = (state = createState(setState, getState, api))
  return api as any
}
```

## useStore

- stateì˜ ë³€í™”ë¥¼ ê°ì§€
- useSyncExternalStoreWithSelector
- useDebugValue
    
    [useDebugValue â€“ React](https://react.dev/reference/react/useDebugValue)
    

```tsx
export function useStore<TState, StateSlice>(
  api: WithReact<StoreApi<TState>>,
  selector: (state: TState) => StateSlice = identity as any,
  equalityFn?: (a: StateSlice, b: StateSlice) => boolean,
) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe, // í´ë¡œì €
    api.getState, // í´ë¡œì €
    api.getServerState || api.getInitialState, // í´ë¡œì €
    selector, // í´ë¡œì €
    equalityFn,
  )
  useDebugValue(slice)
  return slice
}
```

### useSyncExternalStoreWithSelector

- React 18ë²„ì „ì˜ useSyncExternalStore í›…ì„ ì´ì „ ë²„ì „(16, 17ë²„ì „)ê³¼ í˜¸í™˜ë˜ë„ë¡ êµ¬í˜„ëœ shim code
- Reactì˜ useSyncExternalStore
    - ì™¸ë¶€ ìŠ¤í† ì–´(external store)ì™€ ì‹±í¬(sync)ë¥¼ ë§ì¶”ëŠ” í›…(use) ì…ë‹ˆë‹¤.
    - ë¦¬ì•¡íŠ¸ì— ë””íœë˜ì‹œê°€ ì—†ëŠ” ìƒíƒœê´€ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜¹ì€ ë¦¬ì•¡íŠ¸ ë””íœë˜ì‹œê°€ ì—†ì–´ì„œ ë Œë”ë§ ë¡œì§ì— ì¡°ê¸ˆ ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆëŠ” ì™¸ë¶€ ìŠ¤í† ì–´ë¥¼ ì—°ê²°ì‹œì¼œì„œ ë¦¬ì•¡íŠ¸ì˜ ë¦¬ë Œë”ë§ ì‹œìŠ¤í…œì— ì˜¬ë¼íƒˆ ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” í›…ì…ë‹ˆë‹¤.
    - ì™¸ë¶€ìŠ¤í† ì–´ì—ì„œ ê°’ì„ ì½ê³ ,
    - 
    
    ```tsx
    import { useSyncExternalStore } from 'react';
    import { todosStore } from './todoStore.js';
    
    function TodosApp() {
      const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
      // ...
    }
    ```
    
    - `subscribe` í•¨ìˆ˜ëŠ” ìŠ¤í† ì–´ë¥¼ êµ¬ë…í•´ì•¼ í•˜ê³ , êµ¬ë… ì·¨ì†Œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
    - `getSnapshot` í•¨ìˆ˜ëŠ” ìŠ¤í† ì–´ì—ì„œ ë°ì´í„°ì˜ ìŠ¤ëƒ…ìƒ·ì„ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.
    - ReactëŠ” ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ì»´í¬ë„ŒíŠ¸ê°€ ìŠ¤í† ì–´ë¥¼ êµ¬ë…í•œ ìƒíƒœë¡œ ìœ ì§€í•˜ê³  ë³€ê²½ ì‚¬í•­ì´ ìˆì„ ë•Œ ë‹¤ì‹œ ë Œë”ë§í•©ë‹ˆë‹¤.
    
    [useSyncExternalStore â€“ React](https://react.dev/reference/react/useSyncExternalStore#usesyncexternalstore)
    
    https://github.com/facebook/react/blob/597ad74e38b8a45c0278289f4293b9ab4433c28b/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L25
    
    [React 18 useSyncExternalStoreì— ëŒ€í•´ì„œ - ì •í˜„ìˆ˜ ê¸°ìˆ  ë¸”ë¡œê·¸](https://junghyeonsu.com/posts/react-use-sync-external-store/)
    

```tsx
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

import * as React from 'react';
import is from 'shared/objectIs';

// Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.
const {useState, useEffect, useLayoutEffect, useDebugValue} = React;

let didWarnOld18Alpha = false;
let didWarnUncachedGetSnapshot = false;

// Disclaimer: This shim breaks many of the rules of React, and only works
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.
export function useSyncExternalStore<T>(
  subscribe: (() => void) => () => void,
  getSnapshot: () => T,
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  getServerSnapshot?: () => T,
): T {

  const value = getSnapshot();
  const [{inst}, forceUpdate] = useState({inst: {value, getSnapshot}});

  // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.
  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;

    // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({inst});
    }
  }, [subscribe, value, getSnapshot]);

  useEffect(() => {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({inst});
    }
    const handleStoreChange = () => {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?

      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({inst});
      }
    };
    // Subscribe to the store and return a clean-up function.
    return subscribe(handleStoreChange);
  }, [subscribe]);

  useDebugValue(value);
  return value;
}

function checkIfSnapshotChanged<T>(inst: {
  value: T,
  getSnapshot: () => T,
}): boolean {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
```

### ì°¸ê³ 

https://www.nextree.io/zustand/
https://ui.toast.com/posts/ko_20210812
